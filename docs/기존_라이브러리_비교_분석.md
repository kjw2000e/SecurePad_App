# 기존 키패드 라이브러리 vs 신규 라이브러리 비교 분석

## 요약

| 구분 | 기존 (keypad_secure) | 신규 (KICASecurePad) |
|------|---------------------|---------------------|
| **언어** | Java 100% | Kotlin 100% |
| **UI** | XML + Activity | Jetpack Compose |
| **아키텍처** | MVC (Activity 중심) | MVVM + Clean Architecture |
| **암호화** | AES-128 (보안 취약) | AES-256 (표준) |
| **키/IV 처리** | 키 = IV (⚠️ 위험) | 키 ≠ IV (✅ 분리) |
| **Min SDK** | 18 | 29 |
| **Target SDK** | 35 | compileSdk 36 |
| **한글 지원** | ✅ 자모 단위 입력 | ✅ 두벌식 실시간 조합 |
| **테마** | 하드코딩 | KeypadColors 커스터마이징 |

---

## 1. 전체 구조 비교

### 기존 라이브러리 (keypad_secure)

```
keypad_secure/
├── KICASecureKeyPad.java      # 영문/특수문자 키패드 Activity
├── KICASecureNumPad.java      # 숫자 키패드 Activity
├── KICASecurePadConst.java    # 상수 정의
├── crypt/
│   ├── AESHelper.java         # AES-128 암호화
│   ├── RSAHelper.java         # RSA-2048 암호화
│   ├── KeyManager.java        # SecureRandom 키 생성
│   └── MACHelper.java         # HMAC-SHA1
├── main/
│   ├── KeyDataManager.java    # 암호화 데이터 관리
│   ├── KeyDataException.java
│   └── Global.java
└── utils/
    └── StringUtil.java
```

**특징:**
- Activity 기반 키패드 (Intent로 호출)
- XML 레이아웃 + Drawable 이미지 버튼
- 리소스 ID를 String으로 조합하여 `getIdentifier()`로 조회

---

### 신규 라이브러리 (KICASecurePad)

```
kicasecurekeypad/
├── SecureKeypad.kt            # 메인 Composable (진입점)
├── viewmodel/
│   └── KeypadViewModel.kt     # StateFlow 상태 관리
├── domain/model/
│   ├── Key.kt, KeyType.kt     # 키 데이터 모델
│   ├── KeypadConfig.kt        # 설정 (maxLength, colors 등)
│   ├── KeypadColors.kt        # 테마 설정
│   ├── InputIndicatorStyle.kt # DOT, BOX, UNDERLINE, TEXT
│   └── InputValidation.kt     # 검증 규칙
├── data/layout/
│   ├── NumericLayout.kt       # 숫자 배열
│   ├── EnglishLayout.kt       # QWERTY 배열
│   ├── KoreanLayout.kt        # 두벌식 배열 ⭐
│   └── SpecialCharLayout.kt   # 특수문자 배열
├── ui/
│   ├── KeypadButton.kt        # Composable 버튼
│   ├── InputDisplay.kt        # 입력 인디케이터
│   └── KeypadHeader.kt        # 헤더 UI
├── security/
│   ├── AESHelper.kt           # AES-256 암호화 ⭐
│   ├── RSAHelper.kt           # RSA-2048
│   ├── KeyManager.kt          # Keystore + 세션 키
│   ├── MACHelper.kt           # HMAC-SHA1
│   └── KeyDataManager.kt      # 암호화 데이터 관리
└── utils/
    ├── HangulAssembler.kt     # 한글 조합 상태 관리 ⭐
    ├── HangulComposer.kt      # 자모 조합 로직 ⭐
    └── StringUtil.kt
```

**특징:**
- Composable 기반 (XML 불필요)
- ViewModel + StateFlow로 Reactive 상태 관리
- 한글 두벌식 실시간 조합 지원

---

## 2. 암호화 비교 (Critical)

### 기존: AES-128 + 키=IV 동일 ⚠️ 보안 취약

```java
// 기존 AESHelper.java
public static byte[] encrypt(byte[] key, byte[] content) {
    byte[] keyBytes = new byte[16];  // ❌ 16바이트 = AES-128
    System.arraycopy(key, 0, keyBytes, 0, length);
    
    SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");
    IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);  // ❌ 키 = IV
    cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);
}
```

**문제점:**
1. AES-128 (16바이트) - 현재 권장은 AES-256
2. 키와 IV가 동일 - 암호화 표준 위반, 패턴 분석 취약

---

### 신규: AES-256 + 키/IV 분리 ✅ 표준 준수

```kotlin
// 신규 AESHelper.kt
fun encrypt(key: ByteArray, iv: ByteArray, content: ByteArray): ByteArray {
    require(key.size == 32) { "AES-256 requires 32-byte key" }  // ✅ 32바이트
    require(iv.size == 16) { "IV must be 16 bytes" }
    
    val keySpec = SecretKeySpec(key, "AES")
    val ivSpec = IvParameterSpec(iv)  // ✅ 키 ≠ IV
    cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec)
}
```

```kotlin
// 신규 KeyManager.kt
fun generateAESKey(): SecretKey {
    val keyGen = KeyGenerator.getInstance("AES")
    keyGen.init(256)  // ✅ AES-256
    return keyGen.generateKey()
}

fun generateIV(): ByteArray {
    val iv = ByteArray(16)
    SecureRandom().nextBytes(iv)  // ✅ IV 별도 생성
    return iv
}
```

**개선점:**
1. AES-256 (32바이트) - 금융권 표준
2. 키/IV 분리 - 암호화 표준 준수
3. Android Keystore 통합 - TEE 하드웨어 보호

---

## 3. 키 데이터 블록 비교

### 기존: 16바이트 블록

```java
// KeyDataManager.java
private static final int LEN_KEYDATA = 16;

// 입력: 1바이트 실데이터 + 15바이트 랜덤 패딩
byte[] madeKeyData = new byte[16];
System.arraycopy(randomString(16).getBytes(), 0, madeKeyData, 0, 16);
System.arraycopy(keyData, 0, madeKeyData, 0, 1);  // 첫 바이트만 실제 데이터
```

### 신규: 32바이트 블록

```kotlin
// KeyDataManager.kt
private const val LEN_KEYDATA = 32  // 데이터 블록 크기

// 블록 구조: | Length(1) | Data(15) | Random Padding(16) |
// 32바이트를 16바이트씩 나눠서 암호화
```

---

## 4. E2E 패킷 구조

### 기존

```
| RSA 암호화 대칭키 (256B) | AES 암호화 데이터 (16B × N) | HMAC-SHA1 (20B) |
```

- 대칭키: 16바이트 (키=IV)
- 데이터 블록: 16바이트

### 신규

```
| RSA 암호화 키+IV (256B) | AES 암호화 데이터 (32B × N) | HMAC-SHA1 (20B) |
```

- RSA 복호화 → 48바이트 (키 32 + IV 16)
- 데이터 블록: 32바이트

---

## 5. UI 아키텍처 비교

### 기존: Activity + XML

```java
// Intent로 키패드 호출
Intent intent = new Intent(this, KICASecureKeyPad.class);
intent.putExtra(MAX_LENGTH, 20);
intent.putExtra(SECURITY_MODE, SECURITY_MODE_E2E);
startActivityForResult(intent, REQUEST_CODE);

// 결과 수신
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    byte[] result = data.getByteArrayExtra(PASSWORD_RESULT);
}
```

**단점:**
- Activity 전환 오버헤드
- Fragment 상태 관리 복잡
- 화면 회전 시 상태 유실 가능

---

### 신규: Composable

```kotlin
// 직접 삽입
SecureKeypad(
    config = KeypadConfig(
        type = KeypadType.ALPHANUMERIC,
        maxLength = 20,
        colors = KeypadColors.kica()
    ),
    onComplete = { plaintext ->
        // 결과 처리
    }
)
```

**장점:**
- 화면 내 직접 삽입 (Bottom Sheet, Dialog 등)
- StateFlow로 자동 상태 복원
- 테마 커스터마이징 용이

---

## 6. 한글 지원 비교

### 기존: 자모 단위 입력

리소스 파일에 한글 자모 정의:

```xml
<!-- secure_keystrings.xml -->
<string name="secure_btn_char1_shift1_0">ㅂ</string>
<string name="secure_btn_char1_shift1_1">ㅈ</string>
...
<!-- 쌍자음 (shift4) -->
<string name="secure_btn_char1_shift4_0">ㅃ</string>
```

**방식**: 
- 사용자가 ㅂ, ㅏ, ㅂ 입력 → **3개의 개별 자모**로 저장
- 조합 없이 그대로 전송

### 신규: 두벌식 실시간 조합

```kotlin
// HangulAssembler.kt
class HangulAssembler {
    private var chosung: Char? = null   // 초성
    private var jungsung: Char? = null  // 중성
    private var jongsung: Char? = null  // 종성
    
    fun append(char: Char): String  // 자모 입력 → 조합 결과
    fun backspace(): String         // 스마트 삭제 (각→가→ㄱ→삭제)
}
```

**방식**:
- 사용자가 ㅂ, ㅏ, ㅂ 입력 → **"밥"** 완성 문자로 저장
- 실시간 조합 + 스마트 백스페이스 지원

| 비교 | 기존 | 신규 |
|------|------|------|
| 저장 형식 | 자모 분리 | 완성형 문자 |
| 조합 처리 | ❌ 없음 | ✅ 실시간 조합 |
| 백스페이스 | 자모 1개 삭제 | 종성→중성→초성 순차 삭제 |
| 복합모음 | ❌ | ✅ ㅘ, ㅙ, ㅝ 등 |

---

## 7. 검증/테마

### 기존: 하드코딩

- 고정된 Drawable 이미지
- 색상 변경 불가
- 입력 검증 없음

### 신규: 설정 기반

```kotlin
KeypadConfig(
    type = KeypadType.NUMERIC,
    maxLength = 6,
    validation = InputValidation(
        minLength = 4,
        regex = "^[0-9]+$",
        customValidator = { if(it == "0000") "0000은 불가" else null }
    ),
    colors = KeypadColors.lavender(),
    inputIndicatorStyle = InputIndicatorStyle.DOT
)
```

---

## 8. 결론: 주요 개선 사항

| 영역 | 기존 | 신규 | 효과 |
|------|-----|------|------|
| 보안 | AES-128, 키=IV | AES-256, 키≠IV | 보안 2배 강화 |
| 언어 | Java | Kotlin | 생산성/안전성 향상 |
| UI | Activity + XML | Compose | 유연성 극대화 |
| 상태관리 | Handler/Thread | StateFlow | 메모리 안전 |
| 한글 | 자모 단위 입력 | 실시간 조합 | 완성형 문자 지원 |
| 테마 | 하드코딩 | 설정 기반 | 커스터마이징 |
| 검증 | 없음 | regex/custom | 입력 검증 강화 |

---

*분석일: 2026-01-25*
*분석 도구: Antigravity Code Assistant*
