# KICA SecureKeypad 암호화 분석

## 개요

KICA SecureKeypad는 **하이브리드 암호화(Hybrid Encryption)** 방식을 사용합니다:

- **AES-256**: 입력 데이터를 암호화 (대칭키 암호화)
- **RSA-2048**: AES 키와 IV를 암호화하여 안전하게 서버로 전송 (비대칭키 암호화)
- **HMAC-SHA1**: 데이터 무결성 검증

## 1. AES-256 암호화 (대칭키)

### 알고리즘 사양
- **알고리즘**: AES (Advanced Encryption Standard)
- **키 길이**: 256비트 (32바이트) ⭐ **표준 KeyGenerator 사용**
- **IV 길이**: 128비트 (16바이트) ⭐ **키와 별도 생성**
- **모드**: CBC (Cipher Block Chaining)
- **패딩**: NoPadding (수동 패딩 구현)

### 키 생성 방식 (표준)

```kotlin
// KeyManager.kt
fun generateAESKey(): SecretKey {
    val keyGen = KeyGenerator.getInstance("AES")
    keyGen.init(256)  // AES-256
    return keyGen.generateKey()
}

fun generateIV(): ByteArray {
    val iv = ByteArray(16)
    SecureRandom().nextBytes(iv)
    return iv
}
```

### 암호화 과정

1. **초기화 시** (`KeyDataManager.initialize()`):
   - 표준 `KeyGenerator`로 **32바이트 AES-256 키** 생성
   - `SecureRandom`으로 **16바이트 IV** 별도 생성
   - 키 + IV를 **48바이트로 결합**하여 RSA 암호화

2. **문자 입력 시** (`appendCharacter()`):
   - UTF-8 인코딩된 문자 → 32바이트 블록 생성
   - 블록 구조: `| Length(1) | Data(15) | Random Padding(16) |`
   - 32바이트 블록을 16바이트씩 나눠서 AES-256으로 암호화
   - **중요**: 모든 입력에 동일한 키와 IV 사용 (세션 동안 유지)

### 구현 위치
- **키 생성**: `security/KeyManager.kt` - `generateAESKey()`, `generateIV()`
- **암호화/복호화**: `security/AESHelper.kt` - `encrypt()`, `decrypt()`
- **키 관리**: `security/KeyDataManager.kt` - `initialize()`, `appendCharacter()`

## 2. RSA-2048 암호화 (비대칭키)

### 알고리즘 사양
- **알고리즘**: RSA (Rivest-Shamir-Adleman)
- **키 길이**: 2048비트 (256바이트 암호문)
- **패딩**: PKCS#1 v1.5 (PKCS1Padding)
- **입력 데이터**: 48바이트 (32바이트 키 + 16바이트 IV)
- **출력 데이터**: 256바이트 (고정)

### 키 전송 프로세스

```kotlin
// KeyDataManager.kt - initialize()
val secretKey = KeyManager.generateAESKey()  // 32바이트
val iv = KeyManager.generateIV()             // 16바이트
val combined = KeyManager.combineKeyAndIV(secretKey, iv)  // 48바이트

// RSA 공개키로 48바이트 암호화 → 256바이트
val encrypted = RSAHelper.encrypt(publicKey, combined)
```

### 구현 위치
- **RSA 암호화**: `security/RSAHelper.kt` - `encrypt()`, `loadPublicKey()`
- **키 결합**: `security/KeyManager.kt` - `combineKeyAndIV()`, `extractKey()`, `extractIV()`
- **공개키 파일**: `assets/vkeypad_public.pem`

## 3. HMAC-SHA1 (무결성 검증)

### 알고리즘 사양
- **알고리즘**: HMAC-SHA1 (Hash-based Message Authentication Code)
- **해시 길이**: 160비트 (20바이트)
- **키**: AES-256 키 (32바이트) 사용
- **대상 데이터**: RSA 암호화된 키+IV(256바이트) + AES 암호화된 입력 데이터

### 구현 위치
- **HMAC 생성**: `security/MACHelper.kt` - `hmacSha1()`

## 4. 데이터 흐름

### 로컬 저장용 (앱 내부)

```
사용자 입력 "abc"
  ↓
각 문자를 32바이트 블록으로 변환 (Length + Data + Random Padding)
  ↓
AES-256 암호화 (키: 32바이트, IV: 16바이트)
  ↓
암호화된 블록 3개: 96바이트 (32 × 3)
  ↓
Hex 인코딩 → 192자 문자열
```

### 서버 전송용 (E2E 암호화)

```
초기화:
  KeyGenerator → AES-256 키 (32바이트)
  SecureRandom → IV (16바이트)
  키 + IV 결합 → 48바이트
  RSA-2048 암호화 → 256바이트

입력 암호화:
  "abc" → AES-256으로 각 문자 암호화 → 96바이트

서버 전송 패킷 구조 (총 372바이트):
┌─────────────────┬────────────────┬──────────────┐
│ RSA 암호화 키+IV │ AES 암호화 데이터 │  HMAC-SHA1   │
│   256바이트      │    96바이트     │   20바이트    │
│ (48바이트 평문)  │   (3문자)       │  (무결성)     │
└─────────────────┴────────────────┴──────────────┘
```

**패킷 크기 계산**:
- RSA 암호화된 키+IV: 256바이트 (고정)
- AES 암호화된 데이터: 입력 수 × 32바이트
- HMAC: 20바이트 (고정)
- **총합**: 256 + (입력 수 × 32) + 20 바이트

예시:
- "abc" (3문자): 256 + 96 + 20 = **372바이트**
- "123456" (6문자): 256 + 192 + 20 = **468바이트**

## 5. 보안 특징

### AES-256 보안
✅ **표준 KeyGenerator 사용**: `javax.crypto.KeyGenerator`로 안전한 키 생성  
✅ **키와 IV 분리**: 암호화 표준 준수 (동일 값 사용 시 패턴 노출 방지)  
✅ **48바이트 결합 구조**: 키(32) + IV(16)를 함께 전송하여 복호화 보장  
✅ **랜덤 패딩**: 각 입력마다 16바이트 랜덤 패딩으로 빈도 분석 공격 차단

### RSA-2048 보안
✅ **2048비트 키**: 현재 금융권 표준 (NIST 권장)  
✅ **48바이트 암호화**: AES 키 + IV를 안전하게 서버로 전송  
✅ **고정 256바이트 출력**: 입력 크기 은닉

### 추가 보안 계층
✅ **FLAG_SECURE**: 스크린샷/화면 녹화 차단  
✅ **메모리 보안**: `secureClear()`로 사용 후 키 제로화  
✅ **HMAC 검증**: 데이터 변조 감지

## 6. 서버 복호화 과정

```kotlin
// 서버에서의 복호화 예시
fun decryptFromClient(packet: ByteArray): String {
    // 1. RSA 개인키로 첫 256바이트 복호화 → 48바이트 획득
    val encryptedKeyIV = packet.copyOfRange(0, 256)
    val keyIV = RSAHelper.decrypt(privateKey, encryptedKeyIV)  // 48바이트
    
    // 2. 48바이트에서 키(32) + IV(16) 분리
    val aesKey = keyIV.copyOfRange(0, 32)
    val iv = keyIV.copyOfRange(32, 48)
    
    // 3. HMAC 검증
    val dataLength = packet.size - 20
    val hmac = packet.copyOfRange(dataLength, packet.size)
    val expectedHmac = MACHelper.hmacSha1(aesKey, packet.copyOfRange(0, dataLength))
    if (!hmac.contentEquals(expectedHmac)) {
        throw SecurityException("HMAC verification failed")
    }
    
    // 4. AES-256으로 입력 데이터 복호화
    val encryptedData = packet.copyOfRange(256, dataLength)
    val plaintext = AESHelper.decrypt(aesKey, iv, encryptedData)
    
    return String(plaintext, Charsets.UTF_8)
}
```

## 7. 보안 강화 포인트

### 이전 방식 (취약점)
❌ AES-128 (16바이트) 사용  
❌ 키와 IV가 동일 (보안 취약)  
❌ 단순 `SecureRandom.nextBytes()` 키 생성

### 현재 방식 (표준)
✅ **AES-256 (32바이트)** - 보안 강도 2배  
✅ **키와 IV 분리** - 암호화 표준 준수  
✅ **표준 KeyGenerator** - `javax.crypto.KeyGenerator` 사용  
✅ **48바이트 결합** - 키 + IV를 함께 안전하게 전송---

*작성일: 2026-01-10*
*분석 도구: Antigravity Code Assistant*
