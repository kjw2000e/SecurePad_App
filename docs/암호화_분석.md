# KICASecureKeypad 암호화 분석 보고서

## 1. 개요 (Overview)

본 프로젝트는 **AES + RSA + HMAC**을 조합한 **하이브리드 암호화 체계(Hybrid Encryption)**를 사용하여 사용자 입력 데이터의 기밀성과 무결성을 보장합니다.

*   **기밀성 (Confidentiality)**: AES-128 대칭키 암호화 및 RSA-2048 비대칭키 암호화 사용
*   **무결성 (Integrity)**: HMAC-SHA1 메시지 인증 코드 사용
*   **안전성 (Security)**: SecureRandom 난수 생성 및 랜덤 패딩 구조 적용

---

## 2. 암호화 상세 명세 (Specifications)

### 2.1. AES (대칭키 암호화)
사용자 입력값(키스트로크)을 즉시 암호화하는 데 사용됩니다.

*   **알고리즘**: `AES/CBC/NoPadding`
*   **키 길이**: 128-bit (16 Bytes)
*   **IV (초기화 벡터)**: 대칭키와 동일한 값 사용 (16 Bytes)
*   **구현 위치**: `security/AESHelper.kt`

### 2.2. RSA (비대칭키 암호화)
세션별로 생성된 AES 대칭키를 서버로 안전하게 전송하기 위해 사용됩니다.

*   **알고리즘**: `RSA/ECB/PKCS1Padding`
*   **키 길이**: 2048-bit (256 Bytes 출력)
*   **공개키**: `assets/vkeypad_public.pem`
*   **구현 위치**: `security/RSAHelper.kt`

### 2.3. HMAC (무결성 검증)
전송 구간 데이터의 위/변조를 방지하기 위해 사용됩니다.

*   **알고리즘**: `HmacSHA1`
*   **MAC 길이**: 160-bit (20 Bytes)
*   **구현 위치**: `security/MACHelper.kt`

### 2.4. 난수 생성
예측 불가능한 키 및 패딩 생성을 위해 사용됩니다.

*   **방식**: `java.security.SecureRandom`
*   **구현 위치**: `security/KeyManager.kt`

---

## 3. 데이터 흐름 및 포맷 (Data Flow)

### 3.1. 로컬 키스트로크 저장 (Local Storage)
사용자가 키패드를 누를 때마다 `KeyDataManager.appendKeyData()`를 통해 저장됩니다.

1.  **입력**: 사용자 입력 값 (1 Byte)
2.  **패딩**: `SecureRandom`을 사용한 랜덤 패딩 (15 Bytes) 추가
3.  **블록 생성**: `[랜덤 패딩 15B] + [입력 값 1B]` (총 16 Bytes)
    *   *Note: 실제 코드 구현은 `[입력 값 1B][랜덤 패딩 15B]`인지 혹은 반대인지 `KeyDataManager` 확인 필요 (현재 분석상 `System.arraycopy` 순서 참조)*
    *   분석 결과: `madeKeyData` 생성 시 랜덤 스트링(16B)을 먼저 생성 후, 앞 1바이트를 키 입력값으로 덮어쓰는 구조로 보임 (혹은 그 반대).
    *   코드상: `System.arraycopy(StringUtil.randomString(LEN_KEYDATA).toByte(), 0, madeKeyData, 0, LEN_KEYDATA)` 후 `System.arraycopy(keyData, 0, madeKeyData, 0, 1)` -> **첫 1바이트가 실제 데이터, 뒤 15바이트가 랜덤 패딩**
4.  **암호화**: 생성된 16 Byte 블록을 AES-128로 암호화
5.  **저장**: Hex String 형태로 메모리에 누적 (`encryptedDataHex`)

> **보안 효과**: 동일한 키(예: '1')를 여러 번 눌러도 뒷부분 랜덤 패딩으로 인해 매번 다른 암호문이 생성되어 패턴 분석(Frequency Analysis)을 방지합니다.

### 3.2. E2E 데이터 전송 포맷 (Server Transmission)
서버로 전송되는 최종 데이터(`encryptedE2eData`) 구조입니다.

| 순서 | 데이터 항목 | 크기 | 설명 |
|:---:|---|---|---|
| 1 | **Encrypted Symmetric Key** | 256 Bytes | RSA 공개키로 암호화된 AES 대칭키 |
| 2 | **Encrypted Key Data** | N * 16 Bytes | AES로 암호화된 입력값들의 연속 (N = 입력 글자 수) |
| 3 | **MAC (HMAC)** | 20 Bytes | 위 1+2 데이터에 대한 HMAC-SHA1 해시 |

*   **총 패킷 크기**: `256 + (N * 16) + 20` Bytes

---

## 4. 구현 현황 요약

*   **인프라**: `security/` 패키지 내 `KeyDataManager`, `AESHelper`, `RSAHelper`, `MACHelper` 등 핵심 모듈 구현 완료.
*   **현재 상태**: 라이브러리는 보안 모듈을 완전히 포함하고 있으나, 샘플 앱 연동 단계에서는 사용 편의를 위해 평문 버퍼를 사용하는 경우가 있을 수 있음.
*   **연동 방법**: `KeyDataManager.getInstance(context)`를 통해 싱글톤에 접근하여 `appendKeyData`, `encryptedE2eData` 등을 호출하여 사용.

---

*작성일: 2026-01-10*
*분석 도구: Antigravity Code Assistant*
